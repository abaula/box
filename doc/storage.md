
## Внутренние идентификаторы данных

Все ссылки на данные задаются через смещение в виртуальных данных (в байтах), которое отображается на файлы с данными.

```
struct Identity
{
    long Offset; // смещение в виртуальной структуре данных.
}
```
Размер хранимого значения определяетсяч либо по его описанию в файле метаданных,
либо в самом хранимом значении, т.е. в самой записи на которую ссылается `Offset`.

## Сегменты

Файлы с данными могут быть разделены на сегменты.

- Сегменты упрощают размещение данных на дисках.
- Сегменты упрощают [процедуру сжатия данных](scenarios.md#сжатие-данных-сегментов) без остановки системы.

Файлы сегментов имеют расширение `.seg`.

Каждый файл сегмента имеет заголовок фиксированного размера, который содержит метаданные о размере неактуальных данных в сегменте.

```
struct SegmentFileHeader
{
    int DataSizeBytes; // размер файла в байтах без учёта размера заголовка.
    int FreeDataSizeBytes; // размер свободного места в байтах.
    int AllItemsCount; // общее количество записей содержащихся в сегменте.
    int IrrelevantItemsCount; // количество неактуальных записей в сегменте.
}
```

## Файл fields.meta
- Не [сегментируется](#сегменты).

Содержит метаданные всех полей документа.

формат записи:
- id поля число
- id поля строка
- id поля родителя
- название
- тип данных
- порядок отображения
- описание поля

## Файл field.FF.td.ix.NN.seg
- [Сегментируется](#сегменты).

Индекс B+tree - `терм id-документ id`.

Индекс содержит связь один терм ко многим документам, поэтому используется индекс B+tree.

## Файл terms.NN.seg
- [Сегментируется](#сегменты).

Содержит термы переменной величины - текст.

```
struct Term
{
    int TermSize; // длина терма в байтах.
    byte[] Term; // терм.
}
```

## Файл terms.b.NN.seg
- [Сегментируется](#сегменты).

Если размер терма превышает размер сегмента, то терм сохраняется в разных сегментах.

При этом вычисляется и хранится контрольная сумма терма.

```
struct TermBlocks
{
    int TermHashSize; // длина контрольной суммы терма в байтах.
    byte[] TermHash; // контрольная сумма терма.
    int BlocksCount; // Количество ссылок на данные терма.
    Identity[] Blocks; // ссылки на данные терма.
}
```

## Файл term.n.ix.NN.seg
- [Сегментируется](#сегменты).

Индекс B+tree `терм value-term id` для поиска терма по значению, в случае когда значение числовое.


## Файл term.t.ix.NN.seg
- [Сегментируется](#сегменты).

Индекс B+tree `терм value-term id` для поиска терма по текстовому значению.

Для значений хранится ссылка `Offset` на значение [terms.NN.seg](#файл-termsnnseg) или [terms.b.NN.seg](#файл-termsbnnseg).

**??? Как вариант хэш таблица ???**

## Файл terms.seg.meta
- Не [сегментируется](#сегменты).

Содержат информацию о существующих сегментных файлах термов.

```
struct SegmentInfo
{
    int Number; // Уникальный номер сегмента.
    long Offset; // смещение в виртуальной структуре данных.
    long SizeBytes; // размер файла в байтах без учёта размера заголовка.
    bool IsTermBlock; // если true, то terms.b.NN.seg.
    short SegmentFilePathSize; // длина строки пути к файлу.
    byte[] SegmentFilePath; // путь к файлу в кодировке UTF-8.
}
```

## Файл doc.NN.seg
- [Сегментируется](#сегменты).

Хранение значений документа.

Каждый документ имеет фиксированную длинну записи и порядок полей определённый в [fields.meta](#файл-fieldsmeta).

Запись документа имеет вид:

```
struct Document
{
    Identity[] Terms;
}
```

Для числовых полей в документе хранятся значения, для остальных ссылка на термы `Identity`.


## Файл box.meta


## Файл tran.NN.seg
