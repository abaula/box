
Черновик!!!!

# Сегменты:

мета файлы содержат информацию о существующих сегментных файлах

### файл terms_segm.meta

- offset_from (long)
- offset_to (long)
- segment_number


например запись

1000|2000|10

означает, что данные с offset от 1000 до 2000 (вкл) находятся в сегменте под номером 10, т.е. в файле terms.10.segm

```
!!! как предпочтительный вариант использовать мета данные в названии файла, например, то же самое можно сделать назвав файл terms.1000.2000.segm
ещё лучше кодировать это через известные величины размера сегмента в Кб.
terms.4k.n4398046511103.segm - 4Кб * 4398046511103 = (2^64б - 4Кб)
! При этом можно одновременно использовать файлы разного размера сегмента в Кб, главное, чтобы адреса (offset) не пересекались - такой подход позволяет менять размер сегмента без остановки работы системы, например при переносе данных на новый узел где оптимальнее иметь иной размер сегмента.
Максимальный объем адресуемых данных может составлять 2^64 байт.
```

!!! метод чтения данных вычисляет файлы сегментов где хранится запись (т.к. размер файла сегмента фиксирован) и считывает оттуда данные записи.
что то типа `get_rw_segments(offset, size, segment_size) : segment_info[]`

```
struct SegmentInfo
{
  public string SegmentFilePath;
  public int FileOffset; // смещение внутри файла сегмента
  public int Size;
}
```

!!! Оптимизация памяти - через слияние сегментов, при котором новый сегмент не имеет удалённых данных.
!!! Заголовок файла сегмента должен содержать метаданные о размере удалённых данных в сегменте, быть фиксированного размера.

### doc.segm - данные документа

```
fld_terms:
[
    fld_id,
    term_size // количество term в поле (опционально, присутствует только если поле является массивом см. метаданнные поля)
    term_id <, term_id>  - вынести в отдельный сегмент, с уникальными сочетаниями values.segm (заменить на метку файла values.NN.segm и offset)
]
```

!!!!!!!!! - сложные структуры данных преобразуются в плоские списки полей
например есть структура данных:

```
class MyDoc
{
   public Header[] Headers;
   public Author Author;
}

class Header
{
  public string Name;
  public string[] Versions;
}

class Author
{
  public string Name;
  public string Email;
}
```

Объект MyDoc можно представить как:

```
MyDoc.Headers[0].Name = "my test document"
MyDoc.Headers[0].Version[0] = "1.0"
MyDoc.Headers[0].Version[1] = "1.1"
MyDoc.Author.Name = "John"
MyDoc.Author.Email = "John@mail.com"
```

и преобразовать в плоскую структуру, которая сериализуется "сверху вниз":

```
-------------------------------------------------------------------------
 fld_id | fld                         | term_id | term
-------------------------------------------------------------------------
 ...    | MyDoc.Headers[].Name        | ...     | my test document
 ...    | MyDoc.Headers[].Version[]   | ...     | 1.0
 ...    | MyDoc.Headers[].Version[]   | ...     | 1.1
 ...    | MyDoc.Author.Name           | ...     | John
 ...    | MyDoc.Author.Email          | ...     | John@mail.com
```

### values.NN.segm (чтение отсюда делается по offset, size)

- size
- value <, value>

### terms.NN.segm (чтение отсюда делается по offset, size)

- size
- term

# Индексы

### term_index.segm

- [key] term_id

### fld_NN_term_index.segm (для каждого поля свой индекс)

- [key] term_id
- doc_id <, doc_id> - вынести в отдельный сегмент, с уникальными сочетаниями values.segm (заменить на метку файла values.NN.segm и offset)
